From d1447cbc48fe2128ab46a9999727aeb62983504a Mon Sep 17 00:00:00 2001
From: Beniamino Galvani <bgalvani@redhat.com>
Date: Thu, 9 May 2019 11:47:01 +0200
Subject: [PATCH 2/3] vpn: fix persistent reconnection

Currently we retry to reconnect a persistent VPN only when the
previous state was ACTIVATED, which means that if a single connection
retry fails we stop trying. We should instead keep trying forever
after the first successful initial activation.
---
 src/nm-policy.c             | 30 ++++++++++++++++++------------
 src/vpn/nm-vpn-connection.c |  9 ++++++++-
 src/vpn/nm-vpn-connection.h |  3 ++-
 3 files changed, 28 insertions(+), 14 deletions(-)

diff --git a/src/nm-policy.c b/src/nm-policy.c
index 1faba5c7b..9aa014323 100644
--- a/src/nm-policy.c
+++ b/src/nm-policy.c
@@ -2175,26 +2175,32 @@ vpn_connection_retry_after_failure (NMVpnConnection *vpn, NMPolicy *self)
 {
 	NMPolicyPrivate *priv = NM_POLICY_GET_PRIVATE (self);
 	NMActiveConnection *ac = NM_ACTIVE_CONNECTION (vpn);
-	NMSettingsConnection *connection = nm_active_connection_get_settings_connection (ac);
+	NMActiveConnection *ac_new;
+	NMSettingsConnection *connection;
 	GError *error = NULL;
 
+	connection = nm_active_connection_get_settings_connection (ac);
+
 	/* Attempt to reconnect VPN connections that failed after being connected */
-	if (!nm_manager_activate_connection (priv->manager,
-	                                     connection,
-	                                     NULL,
-	                                     NULL,
-	                                     NULL,
-	                                     nm_active_connection_get_subject (ac),
-	                                     NM_ACTIVATION_TYPE_MANAGED,
-	                                     nm_active_connection_get_activation_reason (ac),
-	                                     (  nm_active_connection_get_state_flags (ac)
-	                                      & NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY),
-	                                     &error)) {
+	ac_new = nm_manager_activate_connection (priv->manager,
+	                                         connection,
+	                                         NULL,
+	                                         NULL,
+	                                         NULL,
+	                                         nm_active_connection_get_subject (ac),
+	                                         NM_ACTIVATION_TYPE_MANAGED,
+	                                         nm_active_connection_get_activation_reason (ac),
+	                                         (  nm_active_connection_get_state_flags (ac)
+	                                          & NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY),
+	                                         &error);
+	if (!ac_new) {
 		_LOGW (LOGD_DEVICE, "VPN '%s' reconnect failed: %s",
 		       nm_settings_connection_get_id (connection),
 		       error->message ?: "unknown");
 		g_clear_error (&error);
 	}
+
+	nm_vpn_connection_set_retried (NM_VPN_CONNECTION (ac_new));
 }
 
 static void
diff --git a/src/vpn/nm-vpn-connection.c b/src/vpn/nm-vpn-connection.c
index 1a07377c9..23e0d6f04 100644
--- a/src/vpn/nm-vpn-connection.c
+++ b/src/vpn/nm-vpn-connection.c
@@ -144,6 +144,7 @@ typedef struct {
 	int ip_ifindex;
 	char *banner;
 	guint32 mtu;
+	gboolean retried;
 } NMVpnConnectionPrivate;
 
 struct _NMVpnConnection {
@@ -981,7 +982,7 @@ plugin_state_changed (NMVpnConnection *self, NMVpnServiceState new_service_state
 			/* If the connection failed, the service cannot persist, but the
 			 * connection can persist, ask listeners to re-activate the connection.
 			 */
-			if (   old_state == STATE_ACTIVATED
+			if (   (old_state == STATE_ACTIVATED || priv->retried)
 			    && priv->vpn_state == STATE_FAILED
 			    && _connection_only_can_persist (self))
 				g_signal_emit (self, signals[INTERNAL_RETRY_AFTER_FAILURE], 0);
@@ -2317,6 +2318,12 @@ on_proxy_acquired (GObject *object, GAsyncResult *result, gpointer user_data)
 	}
 }
 
+void
+nm_vpn_connection_set_retried (NMVpnConnection *self)
+{
+	NM_VPN_CONNECTION_GET_PRIVATE (self)->retried = TRUE;
+}
+
 void
 nm_vpn_connection_activate (NMVpnConnection *self,
                             NMVpnPluginInfo *plugin_info)
diff --git a/src/vpn/nm-vpn-connection.h b/src/vpn/nm-vpn-connection.h
index 38163bee8..dceca8665 100644
--- a/src/vpn/nm-vpn-connection.h
+++ b/src/vpn/nm-vpn-connection.h
@@ -67,8 +67,9 @@ void                 nm_vpn_connection_disconnect      (NMVpnConnection *self,
                                                         NMActiveConnectionStateReason reason,
                                                         gboolean quitting);
 
-NMProxyConfig *      nm_vpn_connection_get_proxy_config (NMVpnConnection *self);
+void                 nm_vpn_connection_set_retried     (NMVpnConnection *self);
 
+NMProxyConfig *      nm_vpn_connection_get_proxy_config (NMVpnConnection *self);
 NMIP4Config *        nm_vpn_connection_get_ip4_config  (NMVpnConnection *self);
 NMIP6Config *        nm_vpn_connection_get_ip6_config  (NMVpnConnection *self);
 const char *         nm_vpn_connection_get_ip_iface    (NMVpnConnection *self, gboolean fallback_device);
-- 
2.21.GIT

